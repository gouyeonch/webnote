# Git 명령어 정리

> 깃은 
>
> **명령어 하나**로만 동작하는 방법과, 
>
> **옵션**을 같이 사용하여 동작하는 방법으로 나뉜다.
>
> 명령어 또한 기본적인 명령어 외에도 하위 명령어들이 있다.
>
> 기본적이 포멧은 다음과 같다

- **<u>git 명령어 또는 옵션</u>**



***



## 깃 설치 및 환경설정

- git --version 

  깃의 버전 정보 확인

- #### *config 명령어*

  >- git config 설정값
  >
  >
  >
  >- git config --unset 이메일주소  
  >
  >	> 기존에 설정된 환경 파일을 삭제
  >
  >
  >
  >- git config user.name 사용자 이름 / git config user.email 이메일주소
  >
  >	>개발자 구별을 위한 로컬 저장소 고유키 설정
  >	>
  >	>.git/config 파일에서 설정값 열람가능
  >
  >
  >
  >- git config global user.name 사용자이름 / git config global user.name 이메일주소
  >
  >	> 개발자 구별을 위한 글로벌(공통된) 고유키 설정
  >	>
  >	> 개인 계정 루트의 .gitconfig 파일을 통해 설정값 열람 가능
  >

- git init (경로명)

  >현재의 기본 폴더에 .git 폴더추가
  >
  >즉, 깃 저장소로 초기화가 된다




- **git status**

  >현재 저장소에 있는 파일들의 추적상태, 영역, 수정 유무를 알려준다
  >
  ><u>이때 .gitignore 파일에 있는 파일들은 관리하지 않는다</u>
  



***



## 커밋  

- **git add 파일이름**

  > 워킹 디렉터리의 파일을 스테이지 영역으로 등록한다
  >
  > 파일이름 대신 .을 입력하면 전체 파일과 폴더를 등록할 수 있다.

  

- git rm --cached 파일이름 / git rm --reset 파일이름

  > 스테이지 영역에 있는 파일을 untracked 상태로 바꿔준다
  >
  > 커밋하기 전에는 cached, 한 번이라도 커밋을 하면 reset을 사용해야 된다



- git mv 파일이름 새파일이름

  > 작업도중 파일이름을 바꿀 수 있다. 물론 앞에 git 명령어를 같이쓰면 자동으로 추적도 된다



- git commit

  > 스테이지 영역의 파일들을 커밋한다(HEAD기준으로 수정사항을 적어둔다)
  >
  > vi 에디터가 뜨면 esc -> i -> 커밋 메세지 입력 -> : + w -> : + q
  >
  > 커밋 메세지는 주로 첫 줄에 요약내용, 한 줄 띄고, 상세내용을 적는다

  - git commit -a

    > 파일 등록과 커밋을 동시에 할 수 있다

  - **git commit -m 커밋메세지**

    > vi 에디터 없이 한 줄 짜리 메세지로 바로 커밋 할 수 있다.

  - **git commit -am 커밋메세지**
  
    > 파일 등록과 커밋을 동시에 하고 , 
    >
    > vi 에디터 없이 한 줄 메세지로 바로 커밋가능
    >
    > 이때 최초 등록까지 해주진 않는다 (추적상태까지 바꿔주진 않는다)
  
  - git commit --allow-empty-message -m ""
  
    > 메세지 없이 커밋을 한다
  
  - git commit --amend
  
    > 마지막 커밋을 수정 할 수 있다
    >
    > 스테이지가 깨끗한 상태에서 실행시키면 커밋 이름만 바뀌고
    >
    > 파일을 수정하고 스테이지에 올린 후 실행시키면 내용까지 바꿀 수 있다
    >
    > 두 용도 모두 일단 실행시키면 커밋 해시키가 바뀌니 유의하자




- **git log**

  > 커밋 기록을 확인한다
  >
  > 커밋을 최신 기록부터 내림차순으로 정렬된다
  >
  > 커밋 아이디는 SHA1해시키를 사용하며 아주아주대부분의 경우 앞 7자리로 구별 가능하다
  
  - git log - -pretty=short
  
    > 한 줄의 커밋 메시지만 출력한다
  
  
  - git log - -graph
  
    > 브랜치 흐름까지 같이 커밋 기록 확인
  
    - **git log --graph --all**
  
      > 브랜치 흐름까지 같이 커밋 기록 전체 확인
  
  - **git log - -oneline**
  
    > 커밋들을 한 줄로 축약해서 보여준다 많은 커밋을 한 번에 볼때 유용하다
  
  - git log --decorate
  
    > 브랜치가 어떤 커밋을 가리키는지도 같이 출력



- **git diff 커밋코드**

  > 워킹 디렉터리와 해당 커밋의 차이를 출력해준다



- git show 커밋ID

  >  특정 커밋의 상세정보 확인




- git checkout - - 수정파일이름

  > 제일 최신의 커밋으로 파일 내용을 되돌린다(아마 HEAD기준)ㅑㅑㅅ
  >
  > 물론, 작업했던 내용은 삭제된다
  
  


***



## 서버  

> **프로토콜**
>
> **Local vs HTTP vs SSH**
>
> 협업을 하기 위해, 코드를 안전하게 보관하기 위해
>
> 서버를 사용한다
>
> 이때 서버를 사용 할 때 주로 쓰이는 프로토콜 3가지이다
>
> Git 자체에 내장된 프로토콜이 하나 더 있긴 한데 뭔소린지도 모르겠고,
>
> 잘 쓰이지도 안는단다 이건 생략....
>
> 
>
> **Local :** 
>
> 말 그대로 로컬 영역에 원격저장소를 생성하는 것이다
>
> 단점은 예상대로 한 곳에 코드를 몰아놓는게 위험하다는 것이다
>
> NFS가 뭔진 모르겠는데 이거 할 때는 간편하고 효율적으로 사용 할 수 있다고 한다
>
> 
>
> **HTTP :**
>
> 제일 많이 쓴다고 한다
>
> 평소 아이디 비번 입력하는 방식이 이 프로토콜이다
>
> 사용방식이 직관적이면서도 제일 널리 알려져있다
>
> 단점은 아이디 비번 치는게 귀찮을 수도 있고
>
> 뭔가 잘 안맞는 서버가 있다는 데 뭔소린진 모르겠다
>
> 
>
> **SSH :**
>
> 높은 수준의 보안 통신으로 운용되기 때문에
>
> 깃에서 제일 권장한다고 한다
>
> 굉장히 이상적인 프로토콜인 듯 하다
>
> 단점은 익명을 접근 할 수 없다는 것인데 뭔소린진 모르겠다



- **git remote**

  > 원격 저장소 이름(별칭) 목록 확인

  - **git remote -v**

    >원격 저장소 목록 및 URL 확인

  - **git remote add 별칭 폴더경로**

    > 로컬 저장소를 서버로 이용 할 때 쓰이며
    >
    > 폴더 경로만 입력하면 된다

  - **git remote add 별칭 원격저장소URL**

    > 원격 저장소를 서버로 이용 할 때 쓰이며
    >
    > URL을 입력해야 한다 (github)

  - git remote rename 별칭변경전 변경후

    > 별칭 이름 수정

  - git remote show 원격저장소별칭

    > 원격저장소 상세정보 출력

  - git remote rm 원격저장소별칭

    > 원격저장소 삭제
    
    

- **git push 원격저장소별칭** 브랜치이름

  > 별칭 이름을 가지는 서버의 master 브랜치에 현재 브랜치를 업로드한다
  >
  > 처음 푸시하면 원격저장소에 서버 master 브랜치가 생성된다
  >
  > 즉 전송은 로컬과 원격간의 master 브랜치를 동기화 한다고도 볼 수 있다
  >
  > 이때 원격과 로컬 간의 커밋 내역이 다르다면(최신화가 안돼있다면) 거부 된다(pull 필요)

  - git push origin 브랜치이름:새로운브랜치

    > 로컬과 다른 이름으로 원격에 브랜치를 저장

  - git push -u 원격저장소별칭 브랜치이름

    > 원격과 로컬의 업스트림이 활성화 되면
    >
    > 해당 원격의 어떤 브랜치를 전송 할 것인지 명시해서 푸시
    >
    > -u는 --set-upstream의 약자라고 함

  - git push origin - -delete 리모트브랜치이름

    > 원격의 브랜치를 삭제한다
    >
    > 협업하고 있는 브랜치라면 신중해 삭제해야 한다



- **git clone 저장소주소**

  > 저장소를 복제해온다. 일반적인 복제랑은 물론 차이가 있다
  >
  > 초기화 명령어 외에 원격 접속에 필요한 추가설정을 자동으로 수행한다
  >
  > 태그 정보도 같이 가져온다
  
  - git clone - -recurse-submodules 원격url
  
    > 서브모듈까지 자동으로 초기화하고 업데이트한다



- **git pull (원격별칭 브랜치이름)**

  > 원격 저장소의 갱신된 내용을 추가로 내려 받는다(최신화)
  >
  > 충돌 방지를 위해 자주 해주는게 좋다고 한다
  >
  > 혼자 백업용으로 쓴 때 자주 쓰이진 않을 거 같다
  >
  > 협업 할 때 쓰일 것 같다
  >
  > (자동 병합)
  >
  > 태그 정보도 같이 가져오는 거 같다



- git fetch 원격저장소URL

  > 원격 저장소에 커밋된 코드를 임시 브랜치(서버/master)로 받는다 
  >
  > 이때 자동 병합은 해주지 않는다



- git merge 원격저장소별칭/브랜치 이름

  > 자동 병합 되지 않은 커밋을 로컬에 적용 시키기 위해 병합 명령
  >
  > 로컬의 master와 서버/master을 합친다고 보면 된다



***



## 브랜치 

> 브랜치는 기존 코드를 가상으로 분리한다
>
> 분리해서 격리된 브랜치는 독립적으로 작업이 가능하다
>
> 새로운 프로젝트로 발전시켜 나아갈 때 매우 유용한 기능이다
>
> 서로 간섭 없이 코드를 개선하고, 나아가 병합도 가능하다
>
> 쓸데 없이 너무 많이 늘리면 비효율적일 듯

- git branch

  > 브랜치 목록 출력

  - git branch -v

    > 브랜치 이름 , 커밋ID, 커밋 메시지를 같이 출력

  - git branch -r

    > 리모트 브랜치 출력
    
  - git branch -a
  
    > 모든 브랜치 정보 출력
    
  - git branch -vv
  
    > 트레킹 브랜치도 추가로 같이 출력
    
  - **git branch 브랜치이름** 커밋ID
  
    > HEAD 포인터 기준으로 새로운 브랜치 생성
    >
    > 커밋ID 값을 지정하면 해당 HEAD가 아닌 해당 커밋 기준으로 브랜치 생성
    >
    > 브랜치는 항상 커밋의 해시를 기준으로 생성된다
  
  - **git branch -d 브랜치이름**
  
    > 일반적인 삭제 방법이다
    >
    > 현재 자신의 브랜치는 삭제 할 수 없다
    >
    > 단 스테이지 상태가 깔끔해야 한다
    >
    > 워킹 디렉터리에 작업 흔적이 있거나
    >
    > add를 통한 스테이지 인덱스 변경이 있거나
    >
    > 병합되지 않은 브랜치는 삭제 할 수 없다
    >
    > 조건이 엄청 많은데 이거 다 따지기 힘들듯함
  
  - **git branch -D 브랜치이름**
  
    > 강제로 삭제하는 방법이다
    >
    > 현재 자신의 브랜치는 삭제 할 수 없다
    >
    > 해당 브랜치에서 작업했던 
    >
    > 커밋 기록들이 같이 날라가기 때문에
    >
    > 조심해야한다



- git push origin --delete 리모트브랜치이름

  > 원격의 브랜치를 삭제한다
  >
  > 협업하고 있는 브랜치라면 신중해 삭제해야 한다



- **git checkout 브랜치이름**

  > 현재 브랜치를 떠나 다른 브랜치로 변경
  >
  > 이때 워킹 디렉터리를 정리(커밋)하고 변경해야됌

  - git checkout -- 파일이름

    > 파일 이름을 지정해서 브랜치 변경
    >
    > ?이전 커밋으로 이동

  - git checkout -

    > 이전 브랜치로 이동

  - **git checkout -b 브랜치이름**

    > 브랜치를 생성함과 동시에 해당 브랜치로 이동함

  - git checkout -b 새브랜치이름 origin/브랜치이름

    > fetch를 통해 최신화된 리모트 브랜치를 기반으로 복제하여
    >
    > 새 브랜치 생성
    >
    > 원격 -> 로컬 브랜치 동기화

  - git checkout 태그이름

    > 해당 태그로 체크 아웃된다
    >
    > 브랜치 이름이 태그이름으로 되며 다시 원래 브랜치로 돌아와야한다
    >
    > 단순히 포인터 개념이기 때문에 브랜치처럼 추가로 커밋을 작성 할 수는 없다
    >
    > 추가 작업이 필요하다면 태그를 기반으로 새 브랜치를 작성한다

  - git checkout 커밋해시키(7자리)

    > 커밋해시키와 브랜치이름은 동일하다
    >
    > 커밋 해시키를 통해 브랜치를 바꿀 수 있다
  
  - git checkout HEAD~*n*
  
    > HEAD 포인터 기준으로 n단계 전으로 이동 가능
  
  - git checkout --track origin/브랜치이름
  
    > 업스트림 동작을 위한 트래킹 브랜치 지정
    >
    > 원격에 있던 브랜치의 업스트림 추가 활성화
    >
    > 업스트림이 활성화 되어있지 않으면 해당 브랜치 푸시 못함
  
  - git checkout 태그이름
  
    > 해당 태그로 체크 아웃된다
    >
    > 브랜치 이름이 태그이름으로 되며 다시 원래 브랜치로 돌아와야한다
    >
    > 단순히 포인터 개념이기 때문에 브랜치처럼 추가로 커밋을 작성 할 수는 없다
    >
    > 추가 작업이 필요하다면 태그를 기반으로 새 브랜치를 작성한다



- git push 원격저장소별칭 브랜치이름

  > 해당 브랜치를 원격저장소로 푸쉬
  >
  > 모든 브랜치를 푸시하지 않음
  >
  > 태그는 자동으로 푸시하지 않음

  - git push -u 원격저장소별칭 브랜치이름

    > 원격과 로컬의 업스트림이 활성화 되면
    >
    > 해당 원격의 어떤 브랜치를 전송 할 것인지 명시해서 푸시
    >
    > -u는 --set-upstream의 약자라고 함

  - git push origin 브랜치이름:새로운브랜치

    > 로컬과 다른 이름으로 원격에 브랜치를 저장

  - git push 원격이름 태그이름

    > 일반 브랜치 푸시에 태그 정보는 전송에서 제외되기 때문에
    >
    > 태그를 별도로 푸시해 준다

  - git push 원격이름 - -tags

    > 태그 전부 다 푸시

  - git push 원겨이름 태그이름:다른태그이름

    > 태그를 다른이름으로 전송

  - git push - -delete 원격이름 태그이름

    > 원격에 공유된 태그 삭제
    >
    > 이때 로컬에 있는 태그는 삭제되지 않으므로
    >
    > 따로 삭제를 해주어야 한다(git tag -d)
    >
    > 즉, 태그는 저장소 간 자동으로 동기화되지 않는다



- git merge 원격저장소별칭/브랜치이름

  > 리모트 브랜치가 페치 되면 원격저장소별칭/브랜치 포인터만 생성한다
  >
  > 페치된 브랜치를 로컬에 반영하기 위해 병합
  >
  > 테스트용으로만 사용할 거라면 굳이 병합 X

 



***



## 스태시(stash : to store something in a safe or secret place)  

> 워킹 디렉터리가 깨끗한(clean) 상태로 정리되어 있어야
>
> 깃을 안정적으로 사용 할 수 있고
>
> 브랜치간의 이동도 가능하다
>
> 가끔 작업이 완료되지 않은 채로, 일시적으로 다른 작업을 해야 하는 상황이 있다
>
> 그때 현재 작업을 임시로 저장할 수 있는 스태시 기능을 쓴다



- **git stash**

  > 수정 중인 내역을 커밋하지 않고도
  >
  > 브랜치를 이동할 수 있게 워킹 디렉터리를 깨끗이 청소하고
  >
  > 커밋 대신 현재 작업들을 임시 스택 영역에 저장한다

  - git stash save

    > 스태시 여러 개를 생성할 때 유용 하다는데 뭔소린지 모르겠다

  - git stash save "WIP : 메시지~~"

    > 각각의 스태시를 구별 할 수 있는 메시지를 추가 할 수 있다

  - git stash list

    > 스태시에 저장된 데이터 스택을 확인 할 수 있다
    >
    > 스태시 이름은 stash@{번호} 형태로 순차적으로 부여된다
    >
    > .git/refs/stash에 스태시 객체들이 저장되 있다
    >
    > cat .git/refs/stash 를 통해 객체 확인 가능

  - **git stash pop**

    > 스태시 스택에서 제일 마지막에 저장된 내용을 읽어서
    >
    > 현재 브랜치에 다시 적용시킨다
    >
    > 스태시는 스택에서 내용을 읽어 올 때 
    >
    > 현재 브랜치의 워킹 디렉터리와 자동 병합한다
    >
    > 항목을 가져오면서 동시에 데이터 스택에서 해당 내용이 삭제된다

  - git stash apply stash@{0}

    > 현재 브랜치에 스태시 스택에 저장된 내용을 불러와 복원한다 
    >
    > 스태시 스택에 저장된 항목들은 어느 브랜치에서나 복원이 가능하다
    >
    > pop과 달리 스택 목록을 읽은 후 자동으로 삭제하지 않는다
    >
    > 또한 스택의 가장 마지막 데이터가 아닌 중간 작업을 지정하여 적용할 수 있다
    >
    > 지정하지 않으면 스택 가장 마지막 데이터를 지정한다

  - git stash drop

    > 남아있는 스택 목록을 삭제한다

  - git stash branch 브랜치이름

    > 스테시 충돌이 예상 될 때 사용하는 스테시용 브랜치를 생성함과 동시에 스태시의 임시 작업 내용을 복원함
    >
    > 복구되는 브랜치의 워킹 디렉터리가 깨끗하지 않다면 병합 과정에서 충돌이 발생하는데
    >
    > 충돌에 대비하고 문제를 해결하면 수동으로 삭제하는 거 같음



- git clean 

  > 워킹 디렉터리에 있는 추적되지 않는 파일들을 찾아 삭제한다
  >
  > **-f : 강제 삭제**
  >
  > -n : 파일을 가상으로 미리 처리해 보고 사용자에게 확인을 요청
  >
  > -d : untracked 상태의 파일만 삭제, -f 랑 별로 차이는 없어보임
  >
  > -x : .gitignore 파일에 있는 파일들도 같이 삭제
  >
  > reflog 도 같이 삭제하는게 완벽한 거라는데 아직 뭔소린지 모르겠슴




***



## 병합과 충돌 

> 1. <u>**fast-foward**</u>
>
> 브랜치 경로가 일직선으로 1개만 있을 때
>
> 즉, 서로 다른 브랜치이지만 순차적으로 커밋을 해서 일직선으로 보일 때 쓴다
>
> 작업한 브랜치의 시작 커밋을 원본 브랜치 이후의 커밋으로 가리킨다
>
> 단순히 커밋 위치를 최신을 옯기는 것과 비슷하다 ~ 동기화
>
> 
>
> 2. <u>**3-way**</u>
>
> 기준 커밋에서 서로 다른 브랜치의 커밋이 연결 될때 사용한다
>
> fast-foward 병합과는 달리 브랜치가 좀 더 근명히 나뉘어 있다
>
> 공통 조상 커밋을 포함하는 브랜치(a, d),
>
> 새로운 브랜치 1 (+b), 새로운 브랜치 2 (+c)
>
> 이렇게 3개를 하나로 병합한다 =(a, b, c, d)
>
> 병합 명령을 하면 공통 조상 커밋은 자동으로 찾아 준다
>
> 병합을 완료하면 해당 병합 커밋은 부모 커밋이 2개라는 특징이 있다
>
> 
>
> 3. **<u>rebase</u>**
>
> 커밋을 재배열한다
>
> 커밋의 진행 모습을 단순화하기 위해 많이 쓴다
>
> 병합하는 두 브랜치를 서로 비교하지 않고 순차적으로 커밋 병합을 시도한다
>
> 리베이스는 병합 커밋이 없고, 두 브랜치의 마지막을 가리키는 커밋 위치가  서로 다르다는 특징이 있다
>
> 마지막을 가리키는 커밋 위치가 서로 다르기 때문에 fast-foward를 동해 동기화를 해 줄 필요가 있다
>
> 이때 저장소를 외부에 공개했다면 공개된 순간부터 커밋은 리베이스를 사용하지 않는다는 원칙이 있다
>
> 이는 리베이스를 하는 과정에서 커밋 코드가 바뀌어 혼란을 줄 수 있기 때문이다
>
> 
>
> 똑같은 부분을 다르게 수정하면 충돌이 일어난다
>
> 충돌을 방지하기 위해 master브랜치 내용을 자주 반영하여 병합하는 것이 좋다 ~ 최신화



- **git merge 브랜치이름**

  > 현재 브랜치를 기준으로 다른 브랜치를 병합한다(fast-foward, 3-way)
  >
  > 충돌하면 직접 수정하고 커밋을 만들어야함

  - git merge 브랜치이름 - -edit

    > 자동으로 작성되는 메시지 외에 직접 커밋메시지 작성

  - git merge - -abort

    > 방금 실행한 병합을 취소(특히 충돌 했을때)



- git branch -d 브랜치이름

  > 병합을 마친 브랜치를 삭제 할 때 많이 사용



- git ls-files -u

  > 충돌한 파일들의 집합 확인



- git branch - -merged

  > 병합된 브랜치 목록 출력

- git branch - -no-merged

  > 병합 되지 않은 브랜치 목록 출력



- **git rebase 브랜치**

  > 현재 브랜치를 표적 브랜치로 리베이스

  - git rebase --continue

    >충돌이 일어나면 직접 수정하고
    >
    >스테이지에 올린 후 행당 명령어 입력

  - git rebase --abort

    > 리베이스 취소(특히 충돌 했을때)

  - git rebase -i HEAD~n

    > HEAD기준 n개의 커밋들을 하나로 묶음



***



## 복귀

***reset***

> - git reset - -soft 커밋코드
>
>   > 워킹 디렉터리를 포함한 스테이지 영역을 유지한 채로 해당 커밋으로 복원한다(가장 낮은 단계)
>   >
>   > 스테이지에 그대로 올려져있고 커밋만 사라지기 때문에 그대로 다시 커밋 가능
>   >
>   > 이를 응용해서 n단계 이전에 커밋으로 복원하고 그대로 다시 커밋하면
>   >
>   > n개의 커밋이 하나로 통합된다(git commit --amend와 비슷)
>
> 
>
> - **git reset --mixed 커밋코드**
>
>   > 워킹 디렉터리만를 유지한 채로 해당 커밋으로 복원한다(기본 단계)
>   >
>   > 스테이지 영역은 초기화 되므로 다시 커밋 하려면 add 명령어를 실행 해야 한다
>
> 
>
> - git  reset --hard 커밋코드
>
>   > 커밋 상태와 해당 커밋의 워킹디렉터리까지 모두 되돌린다(가장 높은 단계)
>   >
>   > 해당 커밋이후 모든 내용이 삭제되기 때문에 주의해서 사용해야 한다
>
> 
>
> - git reset (--mixed HEAD) 파일이름
>
>   > 스테이지 영역의 파일을 다시 unstage 상태로 만든다
>
> 
>
> - git reset --merge 커밋코드
>
>   > 병합을 취소한다 바로 이전에 병합한 것만 취소 할 수 있는 것 같다



- git revert 커밋코드

  > 이전 커밋으로 되돌아가기 위해 해당 커밋 이후의 커밋들을 삭제하지 않고 
  >
  > 이전 커밋과 똑같은 커밋을 추가 시킨다
  >
  > 한 번에 커밋 하나만 취소 할 수 있으며 따라서 여려 커밋을 리버트하려면
  >
  > 최신 커밋부터 순차적으로 취소해야 한다
  >
  > 리셋에 비해 실수해도 되돌릴 수 있기 때문에 개인적으로 좋은 것 같음
  >
  > 근데 너무 많이쓰면 커밋 이력이 복잡해 져서 안좋다고 함
  >
  > revert : 되돌아가다

  - git revert 커밋코드 .. 커밋코드

    > 여러 커밋을 리버트한다

  - git revert --m 숫자 병합커밋코드

    > 병합을 취소한다고 가정하고 해당 커밋을 가져온다
    >
    > 어디까지나 가정이기 때문에 메인브랜치와 서브브랜치 중 어떤 걸 가져올지
    >
    > 숫자에 1 또는 2를 입력해서 정한다



> 저장소를 외부에 공개하지 않았다면 reset
>
> 공개했다면 revert를 쓰는게 현명하다고 한다



***



## 배포 관리와 태그

> 완성된 결과물을 최종 사용자에게 전달하는 과정을 배포라고 한다
>
> 배포는 코드를 정리하고 주석들을 정리하는 일종의 최종 결과물을 만드는 과정이라고도 할 수 있다
>
> 배포 프로세스가 빨라지면서
>
> 코드를 안정적으로 유지하고 테스트하기 위한 도구들을 사용 할 줄 알아야 한다
>
> .
>
> 수정 사항들의 차이를 알 수 있게 해주는 것이 <u>버전</u>
>
> 오래된 버전의 프로그램을 최신 코드로 변경하는 것을 <u>버전업</u>이라 한다
>
> n(메이저 번호).n.~(마이너 번호)    SemVer(sementic versioning)방식
>
> 이를 이용해 최종 정리된 커밋에 포인터 개념의 태그를 단다



- git tag 

  > 태그 목록 출력

  - git tag -a 버전 커밋코드

    > Annotated 방식으로 태그를 생성한다(태그이름 + 정보포함)
    >
    > 커밋코드를 비워두면 HEAD가 가리키는 커밋에 태그를 생성한다

  - git tag  버전 커밋코드

    > Lightweight 방식으로 태그를 생성한다(태그이름)
    >
    > 커밋의 체크섬만 가지고 있다 -a, -m 은 불필요

  - git tag -a 버전 -m 메시지

    > vi에디터 없이 한 줄 짜리 메시지 입력
    >
    > 태그가 생성되는 기준은 아마 HEAD기준 인듯 아마

  - git tad -d 태그이름

    > 태그 삭제
    >
    > 태그는 단순히 포인터이므로 커밋이 삭제되지는 않는다



- git show 태그이름

  > 태그의 상세정보 출력



- git checkout 태그이름

  > 해당 태그로 체크 아웃된다
  >
  > 브랜치 이름이 태그이름으로 되며 다시 원래 브랜치로 돌아와야한다
  >
  > 단순히 포인터 개념이기 때문에 브랜치처럼 추가로 커밋을 작성 할 수는 없다
  >
  > 추가 작업이 필요하다면 태그를 기반으로 새 브랜치를 작성한다



- git checkout -b 브랜치이름 태그이름

  > 해당 태그를 기점으로 브랜치를 생성해 커밋을 작성 할 수 있게 해준다



- git push 원격이름 태그이름

  > 일반 브랜치 푸시에 태그 정보는 전송에서 제외되기 때문에
  >
  > 태그를 별도로 푸시해 준다

  - git push 원격이름 - -tags

    > 태그 전부 다 푸시

  - git push 원겨이름 태그이름:다른태그이름

    > 태그를 다른이름으로 전송

  - git push - -delete 원격이름 태그이름

    > 원격에 공유된 태그 삭제
    >
    > 이때 로컬에 있는 태그는 삭제되지 않으므로
    >
    > 따로 삭제를 해주어야 한다(git tag -d)
    >
    > 즉, 태그는 저장소 간 자동으로 동기화되지 않는다







***



## 서브모듈

> 서브모듈은 저장소 하나가 다른 깃 저장소를 포함하는 형태를 의미한다
>
> 저장소 용량을 효율적으로 관리 할 수 있다
>
> 필요에 맞게 작은 저장소로 분할하여 운영하면 큰 프로젝트를 효율적을 관리할 수 있다
>
> .
>
> 원격저장소는 따로 분리되어 있지만
>
> 자식저장소는 부모저장소에 폴더 형태로 남아있다
>
> 따로 푸시하고 각 저장소를 커밋을 통해 갱신한다
>
> 충돌을 방지하기 위해 풀 해줘야 한다
>
> 이때 메인저장소 안의 서브저장소와 서브저장소 원본은 다른 저장소임을 인식



- git submodule add 서브원격url 폴더이름

  > 메인 저장소는 서브 저장소를 폴더 형태로 취급한다
  >
  > 이때 .gitmodules 폴더가 자동 생성되는데 서브 저장소 폴더들을 관리한느 설정 파일이다
  >
  > 명령을 실행하면 서브 폴더를 생성하면
  >
  > 해당 폴더에 서브 원격의 내용을 clone한다

  - git submodules init

    > 메인 저장소를 clone 할 때 서브모듈 정보만 복제할 뿐 실제 하위 저장소는 같이 복제하지 않는다
    >
    > 때문에 하위 저장소는 명령을 통해 직접 가져와야 한다
    >
    > 서브모듈 정보를 기반으로 로컬 환경설정 파일이 준비된다
    >
    > 약간 업스트림 느낌인듯

  - git submodules update

    > 준비된 로컬 환경설정 파일을 기반으로
    >
    > 하위 저장소를 업데이트 한다



- git clone - -recurse-submodules 원격url

  > 서브모듈까지 자동으로 초기화하고 업데이트한다



***



## 고급기능

- git replace

  > 저장소를 분리했다 병합했다가 함
  >
  > 많이쓰이긴 할 듯

- git blame 파일이름

  > 코드를 수정한 사람이 누구인지 언제 수정한 것 인지 쉽게 판별 가능
  >
  > 실무에서 많이 쓰일듯
  >
  > -L 로 특정 부분 지정간으
