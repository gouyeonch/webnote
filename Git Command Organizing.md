# Git 명령어 정리

> 깃은 
>
> **명령어 하나**로만 동작하는 방법과, 
>
> **옵션**을 같이 사용하여 동작하는 방법으로 나뉜다.
>
> 명령어 또한 기본적인 명령어 외에도 하위 명령어들이 있다.
>
> 기본적이 포멧은 다음과 같다

- **<u>git 명령어 또는 옵션</u>**



***



## 깃 설치 및 환경설정

- git --version 

  깃의 버전 정보 확인

- #### *config 명령어*

  >- git config 설정값
  >
  >
  >
  >- git config --unset 이메일주소  
  >
  >	> 기존에 설정된 환경 파일을 삭제
  >
  >
  >
  >- git config user.name 사용자 이름 / git config user.email 이메일주소
  >
  >	>개발자 구별을 위한 로컬 저장소 고유키 설정
  >	>
  >	>.git/config 파일에서 설정값 열람가능
  >
  >
  >
  >- git config global user.name 사용자이름 / git config global user.name 이메일주소
  >
  >	> 개발자 구별을 위한 글로벌(공통된) 고유키 설정
  >	>
  >	> 개인 계정 루트의 .gitconfig 파일을 통해 설정값 열람 가능
  >

- git init (경로명)

  >현재의 기본 폴더에 .git 폴더추가
  >
  >즉, 깃 저장소로 초기화가 된다




- **git status**

  >현재 저장소에 있는 파일들의 추적상태, 영역, 수정 유무를 알려준다
  >
  ><u>이때 .gitignore 파일에 있는 파일들은 관리하지 않는다</u>
  



***



## 커밋  

- **git add 파일이름**

  > 워킹 디렉터리의 파일을 스테이지 영역으로 등록한다
  >
  > 파일이름 대신 .을 입력하면 전체 파일과 폴더를 등록할 수 있다.

  

- git rm --cached 파일이름 / git rm --reset 파일이름

  > 스테이지 영역에 있는 파일을 untracked 상태로 바꿔준다
  >
  > 커밋하기 전에는 cached, 한 번이라도 커밋을 하면 reset을 사용해야 된다



- git mv 파일이름 새파일이름

  > 작업도중 파일이름을 바꿀 수 있다. 물론 앞에 git 명령어를 같이쓰면 자동으로 추적도 된다



- git commit

  > 스테이지 영역의 파일들을 커밋한다(HEAD기준으로 수정사항을 적어둔다)
  >
  > vi 에디터가 뜨면 esc -> i -> 커밋 메세지 입력 -> : + w -> : + q
  >
  > 커밋 메세지는 주로 첫 줄에 요약내용, 한 줄 띄고, 상세내용을 적는다

  - git commit -a

    > 파일 등록과 커밋을 동시에 할 수 있다

  - **git commit -m 커밋메세지**

    > vi 에디터 없이 한 줄 짜리 메세지로 바로 커밋 할 수 있다.

  - **git commit -am 커밋메세지**
  
    > 파일 등록과 커밋을 동시에 하고 , 
    >
    > vi 에디터 없이 한 줄 메세지로 바로 커밋가능
    >
    > 이때 최초 등록까지 해주진 않는다 (추적상태까지 바꿔주진 않는다)
  
  - git commit --allow-empty-message -m ""
  
    > 메세지 없이 커밋을 한다




- **git log**

  > 커밋 기록을 확인한다
  >
  > 커밋을 최신 기록부터 내림차순으로 정렬된다
  >
  > 커밋 아이디는 SHA1해시키를 사용하며 아주아주대부분의 경우 앞 7자리로 구별 가능하다
  
  - git log --pretty=short
  
    > 한 줄의 커밋 메시지만 출력한다
  
  
  - git log --graph
  
    > 브랜치 흐름까지 같이 커밋 기록 확인
  
    - **git log --graph --all**
  
      > 브랜치 흐름까지 같이 커밋 기록 전체 확인



- git show 커밋ID

  >  특정 커밋의 상세정보 확인




- git checkout -- 수정파일이름

  > 제일 최신의 커밋으로 파일 내용을 되돌린다(아마 HEAD기준)ㅑㅑㅅ
  >
  > 물론, 작업했던 내용은 삭제된다
  
  


***



## 서버  

> **프로토콜**
>
> **Local vs HTTP vs SSH**
>
> 협업을 하기 위해, 코드를 안전하게 보관하기 위해
>
> 서버를 사용한다
>
> 이때 서버를 사용 할 때 주로 쓰이는 프로토콜 3가지이다
>
> Git 자체에 내장된 프로토콜이 하나 더 있긴 한데 뭔소린지도 모르겠고,
>
> 잘 쓰이지도 안는단다 이건 생략....
>
> 
>
> **Local :** 
>
> 말 그대로 로컬 영역에 원격저장소를 생성하는 것이다
>
> 단점은 예상대로 한 곳에 코드를 몰아놓는게 위험하다는 것이다
>
> NFS가 뭔진 모르겠는데 이거 할 때는 간편하고 효율적으로 사용 할 수 있다고 한다
>
> 
>
> **HTTP :**
>
> 제일 많이 쓴다고 한다
>
> 평소 아이디 비번 입력하는 방식이 이 프로토콜이다
>
> 사용방식이 직관적이면서도 제일 널리 알려져있다
>
> 단점은 아이디 비번 치는게 귀찮을 수도 있고
>
> 뭔가 잘 안맞는 서버가 있다는 데 뭔소린진 모르겠다
>
> 
>
> **SSH :**
>
> 높은 수준의 보안 통신으로 운용되기 때문에
>
> 깃에서 제일 권장한다고 한다
>
> 굉장히 이상적인 프로토콜인 듯 하다
>
> 단점은 익명을 접근 할 수 없다는 것인데 뭔소린진 모르겠다



- git remote

  > 원격 저장소 이름(별칭) 목록 확인

  - git remote -v

    >원격 저장소 목록 및 URL 확인

  - **git remote add 별칭 폴더경로**

    > 로컬 저장소를 서버로 이용 할 때 쓰이며
    >
    > 폴더 경로만 입력하면 된다

  - **git remote add 별칭 원격저장소URL**

    > 원격 저장소를 서버로 이용 할 때 쓰이며
    >
    > URL을 입력해야 한다 (github)

  - git remote rename 별칭변경전 변경후

    > 별칭 이름 수정

  - git remote show 원격저장소별칭

    > 원격저장소 상세정보 출력

  - git remote rm 원격저장소별칭

    > 원격저장소 삭제
    
    

- **git push 원격저장소별칭** 브랜치이름

  > 별칭 이름을 가지는 서버의 master 브랜치에 현재 브랜치를 업로드한다
  >
  > 처음 푸시하면 원격저장소에 서버 master 브랜치가 생성된다
  >
  > 즉 전송은 로컬과 원격간의 master 브랜치를 동기화 한다고도 볼 수 있다
  >
  > 이때 원격과 로컬 간의 커밋 내역이 다르다면(최신화가 안돼있다면) 거부 된다(pull 필요)

  - git push origin 브랜치이름:새로운브랜치

    > 로컬과 다른 이름으로 원격에 브랜치를 저장

  - git push -u 원격저장소별칭 브랜치이름

    > 원격과 로컬의 업스트림이 활성화 되면
    >
    > 해당 원격의 어떤 브랜치를 전송 할 것인지 명시해서 푸시
    >
    > -u는 --set-upstream의 약자라고 함

  - git push origin --delete 리모트브랜치이름

    > 원격의 브랜치를 삭제한다
    >
    > 협업하고 있는 브랜치라면 신중해 삭제해야 한다



- **git clone 저장소주소**

  > 저장소를 복제해온다. 일반적인 복제랑은 물론 차이가 있다
  >
  > 초기화 명령어 외에 원격 접속에 필요한 추가설정을 자동으로 수행한다



- **git pull**

  > 원격 저장소의 갱신된 내용을 추가로 내려 받는다(최신화)
  >
  > 충돌 방지를 위해 자주 해주는게 좋다고 한다
  >
  > 혼자 백업용으로 쓴 때 자주 쓰이진 않을 거 같다
  >
  > 협업 할 때 쓰일 것 같다
  >
  > (자동 병합)



- git fetch 원격저장소URL

  > 원격 저장소에 커밋된 코드를 임시 브랜치(서버/master)로 받는다 
  >
  > 이때 자동 병합은 해주지 않는다



- git merge 원격저장소별칭/브랜치 이름

  > 자동 병합 되지 않은 커밋을 로컬에 적용 시키기 위해 병합 명령
  >
  > 로컬의 master와 서버/master을 합친다고 보면 된다



***



## 브랜치 

> 브랜치는 기존 코드를 가상으로 분리한다
>
> 분리해서 격리된 브랜치는 독립적으로 작업이 가능하다
>
> 새로운 프로젝트로 발전시켜 나아갈 때 매우 유용한 기능이다
>
> 서로 간섭 없이 코드를 개선하고, 나아가 병합도 가능하다
>
> 쓸데 없이 너무 많이 늘리면 비효율적일 듯

- git branch

  > 브랜치 목록 출력

  - git branch -v

    > 브랜치 이름 , 커밋ID, 커밋 메시지를 같이 출력

  - git branch -r

    > 리모트 브랜치 출력
    
  - git branch -a
  
    > 모든 브랜치 정보 출력
    
  - git branch -vv
  
    > 트레킹 브랜치도 추가로 같이 출력
    
  - **git branch 브랜치이름** 커밋ID
  
    > HEAD 포인터 기준으로 새로운 브랜치 생성
    >
    > 커밋ID 값을 지정하면 해당 HEAD가 아닌 해당 커밋 기준으로 브랜치 생성
    >
    > 브랜치는 항상 커밋의 해시를 기준으로 생성된다
  
  - **git branch -d 브랜치이름**
  
    > 일반적인 삭제 방법이다
    >
    > 현재 자신의 브랜치는 삭제 할 수 없다
    >
    > 단 스테이지 상태가 깔끔해야 한다
    >
    > 워킹 디렉터리에 작업 흔적이 있거나
    >
    > add를 통한 스테이지 인덱스 변경이 있거나
    >
    > 병합되지 않은 브랜치는 삭제 할 수 없다
    >
    > 조건이 엄청 많은데 이거 다 따지기 힘들듯함
  
  - **git branch -D 브랜치이름**
  
    > 강제로 삭제하는 방법이다
    >
    > 현재 자신의 브랜치는 삭제 할 수 없다
    >
    > 해당 브랜치에서 작업했던 
    >
    > 커밋 기록들이 같이 날라가기 때문에
    >
    > 조심해야한다



- git push origin --delete 리모트브랜치이름

  > 원격의 브랜치를 삭제한다
  >
  > 협업하고 있는 브랜치라면 신중해 삭제해야 한다



- **git checkout 브랜치이름**

  > 현재 브랜치를 떠나 다른 브랜치로 변경
  >
  > 이때 워킹 디렉터리를 정리(커밋)하고 변경해야됌

  - git checkout -- 파일이름

    > 파일 이름을 지정해서 브랜치 변경
    >
    > ?이전 커밋으로 이동

  - git checkout -

    > 이전 브랜치로 이동

  - **git checkout -b 브랜치이름**

    > 브랜치를 생성함과 동시에 해당 브랜치로 이동함

  - git checkout -b 새브랜치이름 origin/브랜치이름

    > fetch를 통해 최신화된 리모트 브랜치를 기반으로 복제하여
    >
    > 새 브랜치 생성
    >
    > 원격 -> 로컬 브랜치 동기화

  - git checkout 커밋해시키(7자리)

    > 커밋해시키와 브랜치이름은 동일하다
    >
    > 커밋 해시키를 통해 브랜치를 바꿀 수 있다

  - git checkout HEAD~*n*

    > HEAD 포인터 기준으로 n단계 전으로 이동 가능

  - git checkout --track origin/브랜치이름

    > 업스트림 동작을 위한 트래킹 브랜치 지정
    >
    > 원격에 있던 브랜치의 업스트림 추가 활성화
    >
    > 업스트림이 활성화 되어있지 않으면 해당 브랜치 푸시 못함



- git push 원격저장소별칭 브랜치이름

  > 해당 브랜치를 원격저장소로 푸쉬

  - git push -u 원격저장소별칭 브랜치이름

    > 원격과 로컬의 업스트림이 활성화 되면
    >
    > 해당 원격의 어떤 브랜치를 전송 할 것인지 명시해서 푸시
    >
    > -u는 --set-upstream의 약자라고 함

  - git push origin 브랜치이름:새로운브랜치

    > 로컬과 다른 이름으로 원격에 브랜치를 저장

  

- git merge 원격저장소별칭/브랜치이름

  > 리모트 브랜치가 페치 되면 원격저장소별칭/브랜치 포인터만 생성한다
  >
  > 페치된 브랜치를 로컬에 반영하기 위해 병합
  >
  > 테스트용으로만 사용할 거라면 굳이 병합 X

 



***



## 스태시(stash : to store something in a safe or secret place)  

> 워킹 디렉터리가 깨끗한(clean) 상태로 정리되어 있어야
>
> 깃을 안정적으로 사용 할 수 있고
>
> 브랜치간의 이동도 가능하다
>
> 가끔 작업이 완료되지 않은 채로, 일시적으로 다른 작업을 해야 하는 상황이 있다
>
> 그때 현재 작업을 임시로 저장할 수 있는 스태시 기능을 쓴다



- git stash

  > 수정 중인 내역을 커밋하지 않고도
  >
  > 브랜치를 이동할 수 있게 워킹 디렉터리를 깨끗이 청소하고
  >
  > 커밋 대신 현재 작업들을 임시 스택 영역에 저장한다

  - git stash save

    > 스태시 여러 개를 생성할 때 유용 하다는데 뭔소린지 모르겠다

  - git stash save "WIP : 메시지~~"

    > 각각의 스태시를 구별 할 수 있는 메시지를 추가 할 수 있다

  - git stash list

    > 스태시에 저장된 데이터 스택을 확인 할 수 있다
    >
    > 스태시 이름은 stash@{번호} 형태로 순차적으로 부여된다
    >
    > .git/refs/stash에 스태시 객체들이 저장되 있다
    >
    > cat .git/refs/stash 를 통해 객체 확인 가능

  - git stash pop

    > 스태시 스택에서 제일 마지막에 저장된 내용을 읽어서
    >
    > 현재 브랜치에 다시 적용시킨다
    >
    > 스태시는 스택에서 내용을 읽어 올 때 
    >
    > 현재 브랜치의 워킹 디렉터리와 자동 병합한다
    >
    > 항목을 가져오면서 동시에 데이터 스택에서 해당 내용이 삭제된다

  - git stash apply stash@{0}

    > 현재 브랜치에 스태시 스택에 저장된 내용을 불러와 복원한다 
    >
    > 스태시 스택에 저장된 항목들은 어느 브랜치에서나 복원이 가능하다
    >
    > pop과 달리 스택 목록을 읽은 후 자동으로 삭제하지 않는다
    >
    > 또한 스택의 가장 마지막 데이터가 아닌 중간 작업을 지정하여 적용할 수 있다
    >
    > 지정하지 않으면 스택 가장 마지막 데이터를 지정한다

  - git stash drop

    > 남아있는 스택 목록을 삭제한다

  - git stash branch 브랜치이름

    > 스테시 충돌이 예상 될 때 사용하는 스테시용 브랜치를 생성함과 동시에 스태시의 임시 작업 내용을 복원함
    >
    > 복구되는 브랜치의 워킹 디렉터리가 깨끗하지 않다면 병합 과정에서 충돌이 발생하는데
    >
    > 충돌에 대비하고 문제를 해결하면 수동으로 삭제하는 거 같음



- git clean 

  > 워킹 디렉터리에 있는 추적되지 않는 파일들을 찾아 삭제한다
  >
  > **-f : 강제 삭제**
  >
  > -n : 파일을 가상으로 미리 처리해 보고 사용자에게 확인을 요청
  >
  > -d : untracked 상태의 파일만 삭제, -f 랑 별로 차이는 없어보임
  >
  > -x : .gitignore 파일에 있는 파일들도 같이 삭제
  >
  > reflog 도 같이 삭제하는게 완벽한 거라는데 아직 뭔소린지 모르겠슴
